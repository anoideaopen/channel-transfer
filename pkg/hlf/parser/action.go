package parser

import (
	"github.com/go-errors/errors"
	"github.com/golang/protobuf/proto" //nolint:staticcheck
	"github.com/hyperledger/fabric-protos-go/ledger/rwset"
	"github.com/hyperledger/fabric-protos-go/ledger/rwset/kvrwset"
	"github.com/hyperledger/fabric-protos-go/peer"
)

type prsRwSet struct {
	kvRWSet kvrwset.KVRWSet
}

type prsAction struct {
	payload *peer.ChaincodeActionPayload
}

// proposalResponsePayload returns a pointer to peer.ProposalResponsePayload.
// proposalResponsePayload is the payload of a proposal response.
// This message is the "bridge" between the client's request and the endorser's action in response to that request.
// Concretely, for chaincodes, it contains a hashed representation of the proposal (proposalHash) and a representation of the chaincode state changes and events inside the extension field.
func (a *prsAction) proposalResponsePayload() (*peer.ProposalResponsePayload, error) {
	proposalResponsePayload := &peer.ProposalResponsePayload{}
	if err := proto.Unmarshal(a.payload.GetAction().GetProposalResponsePayload(), proposalResponsePayload); err != nil {
		return nil, errors.Errorf("unmarshal proposal response payload error: %w", err)
	}
	return proposalResponsePayload, nil
}

// chaincodeAction returns a pointer to peer.ChaincodeAction that contains and actions the events generated by the execution of the chaincode.
func (a *prsAction) chaincodeAction() (*peer.ChaincodeAction, error) {
	proposalResponsePayload, err := a.proposalResponsePayload()
	if err != nil {
		return nil, err
	}
	chaincodeAction := &peer.ChaincodeAction{}
	if err = proto.Unmarshal(proposalResponsePayload.GetExtension(), chaincodeAction); err != nil {
		return nil, errors.Errorf("unmarshal chaincode action error: %w", err)
	}
	return chaincodeAction, nil
}

// rwSets returns to a read-write sets slice.
func (a *prsAction) rwSets() ([]prsRwSet, error) {
	chaincodeAction, err := a.chaincodeAction()
	if err != nil {
		return nil, err
	}

	txReadWriteSet := &rwset.TxReadWriteSet{}
	if err = proto.Unmarshal(chaincodeAction.GetResults(), txReadWriteSet); err != nil {
		return nil, errors.Errorf("unmarshal tx read-write set error: %w", err)
	}

	result := make([]prsRwSet, len(txReadWriteSet.GetNsRwset()))
	for i, rwSet := range txReadWriteSet.GetNsRwset() {
		if err = proto.Unmarshal(rwSet.GetRwset(), &result[i].kvRWSet); err != nil {
			return nil, errors.Errorf("unmarshal kv read-write set error: %w", err)
		}
	}
	return result, err
}

func (p *Parser) extractorActionPayload(ccActionPayload *peer.ChaincodeActionPayload) (string, [][]byte, error) {
	ccProposalPayload := &peer.ChaincodeProposalPayload{}
	if err := proto.Unmarshal(ccActionPayload.GetChaincodeProposalPayload(), ccProposalPayload); err != nil {
		return "", nil, errors.Errorf("deserialize ChaincodeProposalPayload: %w", err)
	}

	input := &peer.ChaincodeInvocationSpec{}
	if err := proto.Unmarshal(ccProposalPayload.GetInput(), input); err != nil {
		return "", nil, errors.Errorf("deserialize ChaincodeInvocationSpec: %w", err)
	}

	if input.GetChaincodeSpec().GetInput() == nil {
		return "", nil, nil
	}

	method, args := p.extractChaincodeArgs(input.GetChaincodeSpec().GetInput())

	return method, args, nil
}
